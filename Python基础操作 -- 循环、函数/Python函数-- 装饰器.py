# 装饰器：
#   作用： 在函数名以及函数体不改变的前提下，给函数附加一些额外代码
#   "开放封闭"原则： 已经写好的代码，尽可能不要修改，
#                 如果想要新增功能，在原代码基础上，单独进行扩展
#   "单一功能原则"： 一个函数尽可能只实现一个功能，不要增加一些额外的功能
#   注意： 装饰器的执行时间，是立即执行


#   -------------------------------- 案例1： 发说说、发图片 --------------------------------

# # 定义两个功能函数
# def fss():
#     print('发说说')
#
# def ftp():
#     print('发图片')
#
# # 相关的业务逻辑代码
# btnIndex = 2
# if btnIndex == 1:
#     fss()
# else:
#     fss()


# 发说说，发图片，必须有一个前提，就是，用户必须登录之后，
# 登录验证的操作

# 1，直接在业务逻辑代码里面去修改，添加一个验证操作
#    因为业务逻辑代码非常多，所以，就造成了，每一份，逻辑代码，在调用，具体的功能函数之前都需要，
#    去做一个登录验证，代码冗余度，就比较大，代码的复用性比较差，代码的维护性比较差

# 2，直接在功能函数里面，去修改，方便代码的重用， 但是违背了单一功能原则，不利于代码协作
# 3，使用装饰器，在不改变功能函数  和 业务逻辑函数的情况下，增加新的功能

# 修改

# 定义一个登录功能
def checkLogin(func):
    # 这里采用了闭包
    def inner():
        print('登录验证..')
        func()
    return inner  # 返回的是传入的func函数

# 定义两个功能函数
@checkLogin # 注意 这里的checkLogin函数定义要在使用函数之前
def fss():
    print('发说说')

# 语法糖，写法
@checkLogin
def ftp():
    print('发图片')

# @checkLogin 的功能就等于如下所示
# fsss  = checkLogin(ftp) # 这里的逻辑是： 传入了ftp这个函数给checkLogin，
#                         # 在执行了inner函数后（打印了登录验证）返回ftp这个函数，因此fsss就等于ftp函数，
# print(fsss) # 这里是执行了fsss函数


# 相关的业务逻辑代码
# btnIndex = 1
# if btnIndex == 1:
#     fss()
# else:
#     fss()


# 装饰器的执行时间 -- 立即执行
def check(func):
    print("####")
    def inner():
        print("验证登录 ...")
        func()
    return inner

@check  # 注意，装饰器在这一步时，就已经执行了，而不是在调用fss的时候才会执行，但是里面的inner 函数是不执行的， -- ####
def fss():
    print('发说说')


# 给发说说函数增加一些额外的功能，
# 1， 函数名字不能发生改变
# 2，函数体内部的代码不能发生改变

def check(func):
    def inner():
        print("验证登录 ...")
        func()
    return inner

@check  # 注意，装饰器在这一步时，就已经执行了，而不是在调用fss的时候才会执行
def fss():
    print('发说说')

fss()  # 这里执行了fss函数  返回是： 验证登录 ... 发说说



